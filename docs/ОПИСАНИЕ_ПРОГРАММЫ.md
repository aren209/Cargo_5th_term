# Описание программы: система управления расписанием авиаперевозок

Документ предназначен для специалистов, желающих разобраться во внутренней структуре программы и порядке её функционирования (в соответствии с требованиями к описанию и документированию программ).

---

## 1. Обзор системы

**Система управления расписанием авиаперевозок** — учебный проект, реализующий модель работы малой авиакомпании. Программа позволяет хранить и обрабатывать данные о рейсах, самолётах, аэропортах, грузах (в том числе срочных) и пассажирах, проверять корректность расписания и формировать отчёты.

Система состоит из двух частей:

1. **Ядро на C++** — библиотека классов с логикой предметной области, поставляемая в виде динамической библиотеки (DLL под Windows).
2. **Интерфейс на Python** — привязки к C API (ctypes) и графическое приложение (tkinter) для работы с ядром без программирования на C++.

Общая цель — обеспечить возможность установки на целевую систему и успешное применение пользователем или программистом; для этого предусмотрены документация и средства развёртывания (сборка DLL, запуск GUI).

---

## 2. Структура системы (составные части)

### 2.1. Общая структурная схема

На верхнем уровне систему можно представить так:

```
┌─────────────────────────────────────────────────────────────────┐
│                    Пользователь / Скрипт                         │
└───────────────────────────────┬─────────────────────────────────┘
                                │
┌───────────────────────────────▼─────────────────────────────────┐
│  Python: flight_schedule_gui.py (GUI) / скрипты с API            │
└───────────────────────────────┬─────────────────────────────────┘
                                │
┌───────────────────────────────▼─────────────────────────────────┐
│  Python: flight_schedule_lib.py (привязки ctypes)                │
└───────────────────────────────┬─────────────────────────────────┘
                                │ C API (строки, числа, указатели)
┌───────────────────────────────▼─────────────────────────────────┐
│  C API: FlightScheduleAPI.h/cpp (обёртка extern "C")             │
└───────────────────────────────┬─────────────────────────────────┘
                                │
┌───────────────────────────────▼─────────────────────────────────┐
│  C++: Schedule, Flight, Aircraft, Airport, Cargo,                │
│       UrgentCargo, Passenger (исходники в src/, include/)         │
└─────────────────────────────────────────────────────────────────┘
```

- **Вход**: действия пользователя в GUI или вызовы функций/классов из Python.
- **Выход**: отображение расписания, отчётов, сообщений об ошибках; при программном использовании — строки, числа, флаги успеха.

### 2.2. Модули и их роли

| Компонент | Расположение | Назначение |
|-----------|--------------|------------|
| Классы предметной области | `include/*.h`, `src/*.cpp` | Модель данных и бизнес-логика (рейсы, грузы, самолёты и т.д.) |
| C API | `include/FlightScheduleAPI.h`, `src/FlightScheduleAPI.cpp` | Экспорт возможностей C++ в C-интерфейс для DLL |
| Python-привязки | `python_bindings/flight_schedule_lib.py` | Загрузка DLL, объявление типов ctypes, классы-обёртки |
| GUI | `python_bindings/flight_schedule_gui.py` | Окно приложения, вкладки, формы, вызовы API |
| Сборка DLL | `build_dll.bat` | Запуск компиляции C++ в x64 DLL |

Иерархия классов C++ (упрощённо):

- **Cargo** — базовый класс груза (номер, масса, аэропорты, время).
- **UrgentCargo** — наследник Cargo с полем «срок доставки» и проверкой просрочки.
- **Passenger** — пассажир (номер, имя, аэропорты; масса фиксирована).
- **Aircraft** — самолёт (номер, грузоподъёмность; списки грузов и пассажиров).
- **Airport** — аэропорт (название; списки грузов, пассажиров, самолётов).
- **Flight** — рейс (номер, аэропорты, время вылета/прилёта, самолёт, статус).
- **Schedule** — расписание: контейнер рейсов, сортировка, валидация, отчёты.

Связи: рейс ссылается на самолёт; самолёт везёт грузы и пассажиров; аэропорт хранит грузы, пассажиров и самолёты. C API и Python не добавляют новой доменной логики — только доступ к этим объектам.

---

## 3. Функциональность (операции и стадии)

### 3.1. Последовательность типичного использования

1. **Инициализация**: создание объекта расписания (`Schedule`), при необходимости — самолётов, аэропортов, грузов, пассажиров.
2. **Планирование рейсов**: создание рейсов с указанием маршрута, времени и самолёта; добавление рейсов в расписание.
3. **Проверка**: вызов проверки корректности расписания (конфликты по времени/самолёту и т.п.); при необходимости — автоматическое исправление.
4. **Запросы и отчёты**: получение расписания в целом, расписания по самолёту или за период, отчёта о просроченных срочных грузах.

В GUI те же этапы реализованы через вкладки «Расписание», «Рейсы», «Самолёты», «Аэропорты», «Грузы», «Пассажиры», «Отчёты».

### 3.2. Ключевые операции по подсистемам

- **Грузы**: создание обычного и срочного груза, перемещение между аэропортами, проверка достижения назначения; для срочных — проверка просрочки и срочности (например, < 24 ч до дедлайна).
- **Самолёты**: добавление/удаление грузов и пассажиров с учётом грузоподъёмности, получение текущей загрузки и доступной вместимости.
- **Рейсы**: расчёт длительности, проверка «в процессе» / «запланирован» / «завершён», создание обратного рейса, проверка конфликта с другим рейсом, выгрузка грузов и пассажиров по прибытии.
- **Расписание**: добавление/удаление/поиск рейсов, сортировка по времени вылета, валидация и автоисправление, фильтрация по самолёту/аэропорту/периоду, общее время полётов по самолёту, отчёт по просроченным срочным грузам.

Детальное описание каждой функции и параметров приведено в автоматически генерируемой документации по коду (Doxygen для C++, см. раздел 6).

---

## 4. Средства описания: схемы

### 4.1. Блок-схема подсистем

Ниже — структурная схема основных подсистем и потоков данных (по смыслу лекции: блоки и связи между ними).

```
  ┌──────────────┐     ┌──────────────┐     ┌──────────────┐
  │   Грузы      │     │  Пассажиры   │     │  Самолёты    │
  │ Cargo,       │     │  Passenger   │     │  Aircraft    │
  │ UrgentCargo  │     │              │     │              │
  └──────┬───────┘     └──────┬───────┘     └──────┬───────┘
         │                    │                    │
         └────────────────────┼────────────────────┘
                              │ загрузка/выгрузка
                              ▼
                    ┌──────────────────┐
                    │      Рейс        │
                    │     Flight       │
                    └────────┬─────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
  ┌──────────────┐   ┌──────────────┐   ┌──────────────┐
  │  Аэропорт    │   │  Расписание  │   │  C API /     │
  │  Airport     │   │  Schedule    │   │  Python      │
  └──────────────┘   └──────────────┘   └──────────────┘
```

Смысл элементов описан в тексте раздела 2; при необходимости можно дополнить диаграмму UML классов (например, в PlantUML или аналогах) для наследования (Cargo → UrgentCargo) и ассоциаций (Flight — Aircraft, Schedule — Flight и т.д.).

### 4.2. Иерархия классов (кратко)

- Наследование: **UrgentCargo** наследует **Cargo** (добавлено поле дедлайна, переопределены `toString()`, `isValid()`).
- Агрегация/композиция: в **Aircraft** входят списки грузов и пассажиров; в **Schedule** — список рейсов; в **Airport** — списки грузов, пассажиров, самолётов.
- Ассоциация: **Flight** ссылается на самолёт по идентификатору; рейс связывает аэропорты отправления и назначения.

---

## 5. Описание Python-части

### 5.1. Назначение

- **flight_schedule_lib.py**: загрузка DLL, объявление C-функций через ctypes, классы-обёртки (Schedule, Flight, Aircraft, Airport, Cargo, UrgentCargo, Passenger) с методами и свойствами, соответствующими C API; преобразование строк (UTF-8), времени (datetime ↔ Unix timestamp), буферов для строковых результатов.
- **flight_schedule_gui.py**: главное окно с вкладками; создание одного объекта Schedule и словарей aircrafts/airports для отображения; загрузка тестовых данных; формы ввода и кнопки, вызывающие методы библиотеки; вывод текста в ScrolledText.

### 5.2. Важные детали

- DLL ищется в путях: `../x64/Debug`, `../x64/Release`, текущая директория, имя файла по умолчанию. Проверяется совпадение разрядности DLL и Python (x64/x86); при несовпадении выдаётся понятная ошибка.
- Все строки, передаваемые в C API, кодируются в UTF-8; строки из C декодируются из UTF-8. Время передаётся как Unix timestamp (long long).
- Объекты C++ создаются и уничтожаются через C API; Python-обёртки хранят указатель (handle) и в деструкторе вызывают соответствующую функцию Destroy.

Документация по коду Python (модули, классы, методы, параметры) может быть получена автоматически по docstrings (pydoc или Sphinx), см. раздел 6.

---

## 6. Документирование кода и сборка документации

### 6.1. C++

В проекте используется **Doxygen**. В исходниках расставлены комментарии в формате Doxygen (например, `//!`, `///`, `/** ... */`); в заголовках указаны краткие описания классов, полей и методов.

Генерация HTML-документации:

1. Установить Doxygen (при необходимости).
2. В корне проекта выполнить: `doxygen Doxyfile`.
3. Результат будет в каталоге `docs/cpp/html/` (или как задано в Doxyfile); открыть `index.html`.

Альтернативно можно настроить вывод в другой формат (LaTeX, RTF и т.д.) через Doxyfile.

### 6.2. Python

В модулях `flight_schedule_lib.py` и `flight_schedule_gui.py` используются **docstrings** (PEP 257). Для автоматической документации можно применить:

- **pydoc**: `python -m pydoc python_bindings.flight_schedule_lib` (вывод в консоль или HTML).
- **Sphinx**: при необходимости настроить проект Sphinx с autodoc для этих модулей и получить HTML/PDF.

Для зачёта допускается отдельная документация по C++ и по Python; достаточно HTML для C++ и при необходимости HTML или текстовый документ для Python.

---

## 7. Тестирование и сборка

- **C++**: модульные тесты в каталоге `test/` (например, `test_cargo.cpp`, `test_hierarchy.cpp`, `test_exception.cpp`); сборка и запуск зависят от выбранной системы сборки (например, Visual Studio, x64).
- **Python**: скрипт `python_bindings/test_api.py` проверяет загрузку DLL и базовые операции API; `check_dll.py` проверяет архитектуру DLL и совместимость с Python.
- **Сборка DLL**: скрипт `build_dll.bat` предназначен для запуска из «x64 Native Tools Command Prompt» (Visual Studio); подробности и устранение проблем — в документе «Устранение проблем» в каталоге `docs/`.

---

## 8. Заключение

Система представляет собой двухзвенную архитектуру: C++ ядро с полной моделью авиаперевозок и Python-интерфейс (API и GUI). Описание построено от общего обзора к структуре модулей и классов, затем к функциональности и схемам; документация по коду формируется автоматически (Doxygen для C++, docstrings для Python). Этого достаточно, чтобы разобраться в программе и порядке её работы без обращения к разработчику.

Дополнительные материалы: [README.md](../README.md), [QUICK_START.md](../QUICK_START.md), [PYTHON_GUI_README.md](../PYTHON_GUI_README.md), [УСТРАНЕНИЕ_ПРОБЛЕМ.md](УСТРАНЕНИЕ_ПРОБЛЕМ.md).
